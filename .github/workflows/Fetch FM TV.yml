# This is a basic workflow to help you get started with Actions
name: Fetch TV-FM Files

on:
  schedule:
    - cron: '30 * * * *'
  workflow_dispatch: {} # Enables manual triggering

permissions:
  contents: write

jobs:
  download_and_commit:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download unwrapped M3U Plus file
        run: wget "${{ secrets.IPTV_M3U_URL }}" -O "unwrapped.m3u"

      - name: Download EPG XML file
        run: wget "${{ secrets.IPTV_EPG_URL }}" -O "channel playlist.xml"

      - name: Transform URLs to wrapped format
        env:
          # Pass the full M3U URL into the script's environment
          IPTV_M3U_URL: ${{ secrets.IPTV_M3U_URL }}
        run: |
          python3 << 'EOF'
          import base64
          import re
          import json
          import urllib.parse
          import os

          def wrap_m3u_urls(input_file, output_file):
              """
              Reads an unwrapped M3U file and transforms stream URLs into the proxy-wrapped format.
              """
              # Get the full M3U URL from environment variables
              m3u_url = os.environ.get('IPTV_M3U_URL')
              if not m3u_url:
                  print("Error: IPTV_M3U_URL not found in environment variables.")
                  return

              # Parse the URL to extract username and password
              try:
                  parsed_url = urllib.parse.urlparse(m3u_url)
                  query_params = urllib.parse.parse_qs(parsed_url.query)
                  username = query_params['username'][0]
                  password = query_params['password'][0]
              except (KeyError, IndexError):
                  print("Error: Could not parse 'username' and 'password' from the IPTV_M3U_URL secret.")
                  return
              
              # Construct the prefix dynamically using extracted credentials
              PREFIX = f"http://alt.xtream-ie.org/{username}/{password}/1"
              SUFFIX = "/fast"

              # Groups that need /#.mkv added to URLs
              MKV_GROUPS = {
                  "NETFLIX", "Disney+", "PRIME VIDEO", "HBO MAX", "Peacock TV", 
                  "Paramount+", "SONY Pictures Core", "STARZ", "AMC+", "BritBox", 
                  "Apple TV+", "Others", "Hallmark+", "stan.", "FMTV+", "RTÃˆ PLAYER", 
                  "Angel Studios", "PBS", "DOCPLAY", "CBC Gem", "Peacock TV (Shows)", 
                  "SONY Pictures Core (Shows)", "Stan.", "Studiocanal Presents"
              }

              # Regex to find values from the #EXTINF line
              CUID_PATTERN = re.compile(r'CUID=\"(\d+)\"')
              GROUP_PATTERN = re.compile(r'group-title=\"([^\"]+)\"')
              
              print(f"Starting M3U transformation: {input_file} -> {output_file}")

              try:
                  with open(input_file, 'r', encoding='utf-8') as infile, \
                       open(output_file, 'w', encoding='utf-8') as outfile:
                      
                      lines = infile.readlines()
                      
                      # Check for M3U header and write it with the EPG URL
                      if not lines or lines[0].strip() != "#EXTM3U":
                          print("Error: Input file is missing the '#EXTM3U' header.")
                          return

                      outfile.write('#EXTM3U url-tvg="https://tinyurl.com/FMTV-L1VE-EPG-XML"\n')
                      
                      i = 1 # Start processing from the second line
                      while i < len(lines):
                          extinf_line = lines[i].strip()
                          
                          if extinf_line.startswith("#EXTINF"):
                              outfile.write(extinf_line + '\n')
                              
                              if i + 1 >= len(lines):
                                  i += 1
                                  continue

                              url_line = lines[i+1].strip()
                              
                              if not url_line:
                                  outfile.write(url_line + '\n')
                                  i += 2
                                  continue
                              
                              # Extract CUID and group-title
                              cuid_match = CUID_PATTERN.search(extinf_line)
                              group_match = GROUP_PATTERN.search(extinf_line)
                              
                              if not cuid_match:
                                  outfile.write(url_line + '\n')
                                  i += 2
                                  continue

                              cuid = int(cuid_match.group(1))
                              
                              # Check if this channel belongs to a group that needs /#.mkv
                              needs_mkv = False
                              if group_match:
                                  group_title = group_match.group(1)
                                  needs_mkv = group_title in MKV_GROUPS
                              
                              # Build the JSON payload
                              payload_data = {"url": url_line, "id": cuid}
                              payload_str = json.dumps(payload_data)
                              
                              # Base64 Encode the payload
                              encoded_payload = base64.b64encode(payload_str.encode('utf-8')).decode('utf-8')
                              
                              # URL-safe encode the result
                              url_safe_payload = encoded_payload.replace('=', '%3D')
                              
                              # Construct the final wrapped URL
                              if needs_mkv:
                                  wrapped_url = f'{PREFIX}{url_safe_payload}{SUFFIX}/#.mkv'
                              else:
                                  wrapped_url = f'{PREFIX}{url_safe_payload}{SUFFIX}'
                              
                              outfile.write(wrapped_url + '\n')
                              
                              i += 2
                          else:
                              outfile.write(lines[i]) 
                              i += 1
                          
                  print("Transformation complete.")

              except FileNotFoundError:
                  print(f"Error: File {input_file} was not found.")
              except Exception as e:
                  print(f"An unexpected error occurred: {e}")

          # Execute the transformation
          wrap_m3u_urls('unwrapped.m3u', 'channel playlist.m3u')
          EOF

      - name: Add files to Git
        run: |
          git add "channel playlist.m3u"
          git add "channel playlist.xml"

      - name: Check for changes before commit
        id: changes
        run: |
          if git diff --cached --quiet; then
            echo "no changes"
            echo "changes_detected=false" >> $GITHUB_ENV
          else
            echo "changes_detected=true" >> $GITHUB_ENV
          fi

      - name: Commit changes if any
        if: env.changes_detected == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "github-actions[bot]"
          git commit -m "Updated channel playlist files (M3U with wrapped URLs and EPG XML)"

      - name: Force push changes if commit happened
        if: env.changes_detected == 'true'
        run: |
          git push origin main --force
